import gc
import unittest
import sys
import time

# Import the generated Python code
# This will be generated by: metaffi -c --idl-plugin jvm --idl log4j-api-2.21.1.jar;log4j-core-2.21.1.jar -h python3
GENERATED_CODE_AVAILABLE = False
try:
    # Import the generated log4j classes
    # Expected structure based on the original test:
    # - LogManager class with getLogger method
    # - Logger class with error, warn, info, debug methods
    from log4j import LogManager, Logger
    GENERATED_CODE_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Generated code not found. Run 'python build_metaffi.py' first. Error: {e}")
    print("   This indicates a problem with the JVM IDL plugin or Python311 host compiler.")
    print("   Please check the IDL plugin and host compiler implementations.")
    # Don't create dummy classes - we need to fix the actual problem


def assert_objects_not_loaded_of_type(tc: unittest.TestCase, type_name: str):
    gc.collect()  # Force a garbage collection to update the object list
    all_objects = gc.get_objects()  # Get a list of all objects tracked by the GC
    
    # Convert type_name to lowercase for case-insensitive comparison
    type_name_lower = type_name.lower()
    
    # Find objects whose type name contains the type_name substring, case-insensitively
    specific_type_objects = [obj for obj in all_objects if type_name_lower in type(obj).__name__.lower()]
    
    if len(specific_type_objects) > 0:
        print(f"Found {len(specific_type_objects)} objects of type(s) containing '{type_name}'")
        for obj in specific_type_objects:
            print(f"Object: {obj}, Type: {type(obj).__name__}")
        tc.fail(f"Found {len(specific_type_objects)} objects of type(s) containing '{type_name}'")


class Log4jLogger:
    """Wrapper class that provides a Pythonic interface to log4j using generated code"""
    
    def __init__(self, logger_name: str):
        if not GENERATED_CODE_AVAILABLE:
            raise ImportError("Generated log4j code not available. Please run 'python build_metaffi.py' first.")
        
        # Use the generated LogManager to get a logger
        self.logger = LogManager.getLogger(logger_name)
    
    def error(self, msg: str):
        """Log an error message using the generated Logger.error method"""
        self.logger.error(msg)
    
    def warn(self, msg: str):
        """Log a warning message using the generated Logger.warn method"""
        self.logger.warn(msg)
    
    def info(self, msg: str):
        """Log an info message using the generated Logger.info method"""
        self.logger.info(msg)
    
    def debug(self, msg: str):
        """Log a debug message using the generated Logger.debug method"""
        self.logger.debug(msg)
    
    def __del__(self):
        # Clean up references
        del self.logger


class TestLog4jWithCompiler(unittest.TestCase):
    
    def setUp(self):
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
    
    def test_log_manager_get_logger(self):
        """Test that LogManager.getLogger works with generated code"""
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
        
        # Test that we can get a logger using the generated LogManager
        logger = LogManager.getLogger('TestLogger')
        self.assertIsNotNone(logger)
        
        # Clean up
        del logger
        assert_objects_not_loaded_of_type(self, 'MetaFFIEntity')
    
    def test_logger_error(self):
        """Test that Logger.error method works with generated code"""
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
        
        # Test direct logger usage
        logger = LogManager.getLogger('ErrorTestLogger')
        logger.error('Test error message from Python using generated code!')
        
        # Clean up
        del logger
        assert_objects_not_loaded_of_type(self, 'MetaFFIEntity')
    
    def test_log4j_logger_wrapper(self):
        """Test the Log4jLogger wrapper class using generated code"""
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
        
        # Test the wrapper class
        logger = Log4jLogger('Log4j Logger With Compiler')
        logger.error('Logging error From Python using generated code!')
        logger.warn('Logging warning From Python using generated code!')
        logger.info('Logging info From Python using generated code!')
        logger.debug('Logging debug From Python using generated code!')
        
        # Clean up
        del logger
        assert_objects_not_loaded_of_type(self, 'MetaFFIEntity')
    
    def test_multiple_loggers(self):
        """Test creating multiple loggers with generated code"""
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
        
        # Create multiple loggers
        logger1 = LogManager.getLogger('Logger1')
        logger2 = LogManager.getLogger('Logger2')
        
        # Test that they are different instances
        self.assertIsNot(logger1, logger2)
        
        # Test logging from both
        logger1.error('Error from Logger1')
        logger2.warn('Warning from Logger2')
        
        # Clean up
        del logger1
        del logger2
        assert_objects_not_loaded_of_type(self, 'MetaFFIEntity')


class TestLog4jWithCompilerStatic(unittest.TestCase):
    """Test static methods if they exist in the generated code"""
    
    def test_static_methods(self):
        """Test static method calls if the generated code supports them"""
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
        
        # Test static method calls if they exist
        # This depends on how the generated code structures static vs instance methods
        # For now, we'll test the basic functionality
        
        # Test that LogManager is callable as a static class
        logger = LogManager.getLogger('StaticTestLogger')
        logger.error('Static test message')
        
        # Clean up
        del logger
        assert_objects_not_loaded_of_type(self, 'MetaFFIEntity')


def main():
    """Main function to run the tests"""
    print("Running log4j end-to-end tests with generated Python code...")
    print("Make sure to run 'python build_metaffi.py' first to generate the Python code.")
    
    if not GENERATED_CODE_AVAILABLE:
        print("\nERROR: Generated code not available!")
        print("This indicates a problem with the JVM IDL plugin or Python311 host compiler.")
        print("Please:")
        print("1. Check that the JVM IDL plugin is built")
        print("2. Check that the Python311 host compiler is working")
        print("3. Run 'python build_metaffi.py' to generate the code")
        print("4. Add unit tests to verify the IDL plugin and host compiler work correctly")
        return 1
    
    # Run the tests
    unittest.main(verbosity=2)
    return 0


if __name__ == '__main__':
    exit(main()) 
