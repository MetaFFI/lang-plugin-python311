import gc
import os
import unittest
import collections
import sys
import time

# Import the generated Python code
# This will be generated by: metaffi -c --idl-plugin jvm --idl sanity/ -h python3
GENERATED_CODE_AVAILABLE = False
try:
    from sanity import TestRuntime, TestMap
    from sanity import sanity  # In case the module itself is also generated
    GENERATED_CODE_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Generated code not found. Run 'python build_metaffi.py' first. Error: {e}")
    print("Skipping actual tests and using dummy classes for structure validation only.")
    # Create dummy classes for testing structure
    class TestRuntime:
        def hello_world(self): pass
        def returns_an_error(self): pass
        def div_integers(self, a, b): pass
        def join_strings(self, strings): pass
        def wait_a_bit(self, seconds): pass
        def call_callback(self, callback): pass
        @property
        def five_seconds(self): pass
    
    class TestMap:
        def __init__(self): pass
        def set(self, key, value): pass
        def get(self, key): pass
        def contains(self, key): pass
        @property
        def name(self): pass
        @name.setter
        def name(self, value): pass


def add_callback(x, y):
    return x + y


def assert_objects_not_loaded_of_type(tc: unittest.TestCase, type_name: str):
    gc.collect()  # Force a garbage collection to update the object list
    all_objects = gc.get_objects()  # Get a list of all objects tracked by the GC
    
    # Convert type_name to lowercase for case-insensitive comparison
    type_name_lower = type_name.lower()
    
    # Find objects whose type name contains the type_name substring, case-insensitively
    specific_type_objects = [obj for obj in all_objects if type_name_lower in type(obj).__name__.lower()]
    
    if len(specific_type_objects) > 0:
        print(f"Found {len(specific_type_objects)} objects of type(s) containing '{type_name}'")
        for obj in specific_type_objects:
            print(f"Object: {obj}, Type: {type(obj).__name__}")
        tc.fail(f"Found {len(specific_type_objects)} objects of type(s) containing '{type_name}'")


class TestSanityWithCompiler(unittest.TestCase):
    
    def setUp(self):
        # Initialize test runtime instance
        self.test_runtime = TestRuntime()
    
    def test_hello_world(self):
        """Test calling hello_world method using generated code"""
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
        
        # Call hello world using the generated interface
        self.test_runtime.hello_world()
        
        # Clean up
        del self.test_runtime
        assert_objects_not_loaded_of_type(self, 'MetaFFIEntity')
    
    def test_returns_an_error(self):
        """Test calling returns_an_error method using generated code"""
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
        
        try:
            self.test_runtime.returns_an_error()
            self.fail('Test should have failed')
        except Exception:
            # Expected to fail
            pass
        
        # Clean up
        del self.test_runtime
        assert_objects_not_loaded_of_type(self, 'MetaFFIEntity')
    
    def test_div_integers(self):
        """Test calling div_integers method using generated code"""
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
        
        # Test normal division
        res = self.test_runtime.div_integers(1, 2)
        self.assertEqual(0.5, res)
        
        # Test division by zero (should raise exception)
        try:
            self.test_runtime.div_integers(1, 0)
            self.fail('Expected an error - divisor is 0')
        except Exception:
            # Expected to fail
            pass
        
        # Clean up
        del self.test_runtime
        assert_objects_not_loaded_of_type(self, 'MetaFFIEntity')
    
    def test_join_strings(self):
        """Test calling join_strings method using generated code"""
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
        
        res = self.test_runtime.join_strings(['one', 'two', 'three'])
        self.assertEqual('one,two,three', res)
        
        # Clean up
        del self.test_runtime
        assert_objects_not_loaded_of_type(self, 'MetaFFIEntity')
    
    def test_wait_a_bit(self):
        """Test calling wait_a_bit method and five_seconds property using generated code"""
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
        
        # Get the five seconds value using the generated property
        five_seconds = self.test_runtime.five_seconds
        self.assertEqual(5, five_seconds)
        
        # Call wait_a_bit with the five seconds value
        self.test_runtime.wait_a_bit(five_seconds)
        
        # Clean up
        del self.test_runtime
        assert_objects_not_loaded_of_type(self, 'MetaFFIEntity')
    
    def test_test_map(self):
        """Test TestMap class using generated code"""
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
        
        # Create a new TestMap instance using the generated constructor
        test_map = TestMap()
        
        # Test setting and getting values
        test_map.set('x', 250)
        
        # Test contains method
        res = test_map.contains('x')
        self.assertTrue(res)
        
        # Test get method
        res = test_map.get('x')
        self.assertEqual(250, res)
        
        # Test with complex Python objects
        deq = collections.deque()
        deq.append(600)
        test_map.set('z', deq)
        
        mapped_deq = test_map.get('z')
        self.assertIsInstance(mapped_deq, collections.deque)
        assert isinstance(mapped_deq, collections.deque)  # for the type checker
        val = mapped_deq.pop()
        self.assertEqual(600, val)
        
        # Test name property
        test_map.name = 'MyName'
        name = test_map.name
        self.assertEqual('MyName', name)
        
        # Clean up
        del test_map
        del self.test_runtime
        assert_objects_not_loaded_of_type(self, 'MetaFFIEntity')
    
    def test_callback(self):
        """Test callback functionality using generated code"""
        if not GENERATED_CODE_AVAILABLE:
            self.skipTest('Generated code not available - JVM IDL plugin may not be built')
        
        self.skipTest('Callback from python is not implemented yet')
        
        def add(x: int, y: int) -> int:
            print('in python add from java - {}+{}'.format(x, y), file=sys.stderr)
            return x + y
        
        # Call the callback method using generated code
        self.test_runtime.call_callback(add)
        
        # Clean up
        del self.test_runtime
        assert_objects_not_loaded_of_type(self, 'MetaFFIEntity')


class TestSanityWithCompilerStatic(unittest.TestCase):
    """Test static methods if they exist in the generated code"""
    
    def test_static_methods(self):
        """Test static method calls if the generated code supports them"""
        # This test assumes the generated code might provide static method access
        # like TestRuntime.static_hello_world() or similar
        # Adjust based on actual generated code structure
        
        # Example of how static methods might be called:
        # TestRuntime.hello_world()  # if it's a static method
        # TestRuntime.div_integers(1, 2)  # if it's a static method
        
        # For now, skip this test until we see the actual generated code structure
        self.skipTest('Static method testing depends on generated code structure')


def main():
    """Main function to run the tests"""
    print("Running JVM end-to-end tests with generated Python code...")
    print("Make sure to run 'python build_metaffi.py' first to generate the Python code.")
    
    # Run the tests
    unittest.main(verbosity=2)


if __name__ == '__main__':
    main() 
